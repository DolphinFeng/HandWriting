// 给你一个二进制字符串s,其中至少包含一个'1'。你必须按某种方式重新排列字符串中的位,使得到的二
// 进制数字是可以由该组合生成的最大二进制奇数。以字符串形式,表示并返回可以由给定组合生成的最大二
// 进制奇数。注意返回的结果字符串可以含前导零。示例1:?输入:s="010"输出:"001"解释:因为字符
// 串s中仅有一个'1',其必须出现在最后一位上。所以答案是"001"。示例2:输入:s="0101"输
// 出:"1001"解释:其中一个'1'必须出现在最后一位上。而由剩下的数字可以生产的最大数字是"100"。所以
// 答案是"1001"。


function makeLargestOddBinary(s) {
    let ones = (s.match(/1/g) || []).length;
    let zeros = s.length - ones;
    let result = '1'.repeat(ones);
    result = '0'.repeat(zeros) + result;
    return result;
}
